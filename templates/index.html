<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stream Control</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
      max-width: 1200px;
      margin: 0 auto;
      line-height: 1.6;
    }
    h2 { color: #0a84ff; margin-top: 0; }
    h3 { color: #5ac8fa; margin-top: 24px; }
    label { 
      display: block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #aaa;
      font-size: 14px;
      font-weight: 500;
    }
        input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      margin: 4px 0 12px 0;
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #333;
      border-radius: 4px;
      font-size: 14px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #0a84ff;
      box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.2);
    }
    select {
      cursor: pointer;
    }
    input[type="file"] {
      padding: 8px;
      cursor: pointer;
    }
    .channel-select-group {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }
    .channel-select-group select {
      flex: 1;
    }
    .channel-select-group button {
      flex: 0 0 auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
      background: #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background: #222;
      color: #0a84ff;
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    td {
      color: #e0e0e0;
      font-size: 13px;
    }
    tr:hover {
      background: #252525;
    }
    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .status-running {
      background: #34c759;
      color: #fff;
    }
    .status-stopped {
      background: #ff3b30;
      color: #fff;
    }
    .action-buttons {
      display: flex;
      gap: 6px;
    }
    .action-buttons button {
      padding: 6px 12px;
      font-size: 12px;
      margin: 0;
    }
    .refresh-indicator {
      color: #666;
      font-size: 12px;
      margin-top: 8px;
    }
    button {
      padding: 10px 16px;
      margin: 6px 4px;
      background: #0a84ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }
    button:hover {
      background: #0071e3;
    }
    button:active {
      background: #0051a5;
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 16px 0;
    }
    pre {
      background: #000;
      padding: 16px;
      border-radius: 4px;
      max-height: 400px;
      overflow: auto;
      font-size: 12px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      border: 1px solid #333;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .section {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #222;
    }
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    .source-status {
      margin-top: 12px;
      padding: 8px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      font-size: 12px;
      display: none;
    }
    .source-status.active {
      display: block;
    }
    .source-status.checking {
      color: #0a84ff;
    }
    .source-status.available {
      color: #34c759;
      border-color: #34c759;
    }
    .source-status.unavailable {
      color: #ff3b30;
      border-color: #ff3b30;
    }
    .source-status.timeout {
      color: #ff9500;
      border-color: #ff9500;
    }
  </style>
</head>
<body>
  <h2>Stream Control Panel</h2>
  
  <div class="section">
    <h3>M3U Channel Selector</h3>
    <label>Upload M3U File</label>
    <input type="file" id="m3uFile" accept=".m3u,.m3u8" />
    <button onclick="uploadM3U()" style="margin-top: 8px;">ğŸ“¤ Upload & Load Channels</button>
    
    <label style="margin-top: 20px;">Select Channel</label>
    <div class="channel-select-group">
      <select id="channelSelect" onchange="selectChannel()">
        <option value="">-- Select a channel --</option>
      </select>
      <button onclick="loadChannels()">ğŸ”„ Reload Channels</button>
    </div>
    <small style="color: #666; display: block; margin-top: -8px; margin-bottom: 12px;">
      Total channels: <span id="channelCount">0</span>
    </small>
    
    <div class="source-status" id="sourceStatus">
      <span id="sourceStatusText">Ø¬Ø§Ù‡Ø² Ù„Ù„ÙØ­Øµ</span>
    </div>
  </div>
  
  <div class="section">
    <h3>Stream Settings</h3>
    <label>Authorization Token</label>
    <input id="token" placeholder="Bearer token" value="Bearer {TOKEN_PLACEHOLDER}" />
    
    <label>Stream ID</label>
    <input id="id" value="full_overlay_test" placeholder="Unique stream identifier" />
    
    <label>HLS URL</label>
    <input id="hls" value="http://5.9.243.47:8080/live/wawi/Yyf6Y7gQwC/664.m3u8" placeholder="Input HLS stream URL" />
    
    <label>RTMP URL</label>
    <input id="rtmp" value="{RTMP_URL_PLACEHOLDER}" placeholder="Output RTMP stream URL" />
    
    <label>Image Path (optional)</label>
    <input id="image" value="" placeholder="Path to overlay image" />
    
    <label>Extra Args (JSON array) â€” leave empty to copy video</label>
    <textarea id="extra" rows="4"></textarea>
    
    <label style="margin-top: 20px;">ğŸ“‹ FFmpeg Command (Ù„Ù„Ù†Ø³Ø® ÙˆØ§Ù„ØªØ¬Ø±ÙŠØ¨ Ø§Ù„ÙŠØ¯ÙˆÙŠ)</label>
    <div style="position: relative;">
      <textarea id="ffmpegCommand" rows="4" readonly style="font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; background: #0a0a0a; color: #0a84ff; cursor: text; padding-right: 160px;" onclick="this.select();"></textarea>
      <button id="generateCommandBtn" onclick="generateFFmpegCommand(); return false;" style="position: absolute; top: 8px; right: 8px; padding: 6px 12px; font-size: 12px; background: #34c759; color: white; border: none; border-radius: 4px; cursor: pointer; z-index: 10; margin-right: 70px;" title="Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø±">ğŸ”„ ØªÙˆÙ„ÙŠØ¯</button>
      <button onclick="copyFFmpegCommand(event)" style="position: absolute; top: 8px; right: 8px; padding: 6px 12px; font-size: 12px; background: #0a84ff; color: white; border: none; border-radius: 4px; cursor: pointer; z-index: 10;">ğŸ“‹ Ù†Ø³Ø®</button>
    </div>
    <small style="color: #666; display: block; margin-top: 4px;">
      Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø­Ù‚Ù„ Ù„Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†Øµ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± Ø§Ù„Ù†Ø³Ø® | ÙŠØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ù‚ÙˆÙ„ | Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ù…Ø±
    </small>
  </div>

  <div class="button-group">
    <button onclick="start()">â–¶ Start Stream</button>
    <button onclick="stop()">â–  Stop Stream</button>
    <button onclick="status()">ğŸ“Š Status</button>
    <button onclick="refreshStreamsTable()">ğŸ”„ Refresh</button>
    <button onclick="viewLogs()">ğŸ“„ View Logs</button>
    <button onclick="saveSettings()" style="background: #34c759;">ğŸ’¾ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</button>
  </div>

  <div class="section">
    <h3>Running Streams <span id="streamsCount" style="color: #666; font-size: 14px; font-weight: normal;">(0)</span></h3>
    <div id="streamsTableContainer">
      <table id="streamsTable">
        <thead>
          <tr>
            <th>Stream ID</th>
            <th>Status</th>
            <th>PID</th>
            <th>Uptime</th>
            <th>Log Size</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="streamsTableBody">
          <tr>
            <td colspan="6" style="text-align: center; color: #666; padding: 20px;">
              Loading streams...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="refresh-indicator">
      Auto-refresh: <span id="autoRefreshStatus">Enabled</span> | 
      Last updated: <span id="lastUpdate">Never</span>
      <button onclick="toggleAutoRefresh()" style="margin-left: 12px; padding: 4px 8px; font-size: 11px;">Toggle Auto-Refresh</button>
    </div>
  </div>

  <div class="section">
    <h3>Output</h3>
    <pre id="out">Ready...</pre>
  </div>

<script>
let channelsData = [];

function authHeader() {
  let token = document.getElementById('token').value || '';
  if (!token.startsWith('Bearer ')) {
    token = 'Bearer ' + token;
  }
  return token;
}

async function uploadM3U() {
  const fileInput = document.getElementById('m3uFile');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Please select a file first');
    return;
  }
  
  const formData = new FormData();
  formData.append('file', file);
  
  try {
    const response = await fetch('/m3u/upload', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (response.ok) {
      document.getElementById('out').textContent = 'File uploaded successfully: ' + result.filename + '\n\n' + JSON.stringify(result, null, 2);
      // Automatically load channels after upload
      await loadChannels();
    } else {
      document.getElementById('out').textContent = 'Error: ' + result.error;
    }
  } catch (error) {
    document.getElementById('out').textContent = 'Error: ' + error.message;
  }
}

async function loadChannels() {
  try {
    const response = await fetch('/m3u/channels');
    const result = await response.json();
    
    if (response.ok && result.channels) {
      channelsData = result.channels;
      const select = document.getElementById('channelSelect');
      
      // Clear existing options except the first one
      select.innerHTML = '<option value="">-- Select a channel --</option>';
      
      // Group channels by group title
      const groupedChannels = {};
      result.channels.forEach((channel, index) => {
        const group = channel.group || 'Other';
        if (!groupedChannels[group]) {
          groupedChannels[group] = [];
        }
        groupedChannels[group].push({...channel, index});
      });
      
      // Add options grouped by category
      Object.keys(groupedChannels).sort().forEach(group => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = group;
        
        groupedChannels[group].forEach(channel => {
          const option = document.createElement('option');
          option.value = channel.index;
          option.textContent = channel.name || 'Unnamed Channel';
          optgroup.appendChild(option);
        });
        
        select.appendChild(optgroup);
      });
      
      document.getElementById('channelCount').textContent = result.count;
      document.getElementById('out').textContent = 'Loaded ' + result.count + ' channels from M3U file';
    } else {
      document.getElementById('out').textContent = 'Error: ' + (result.error || 'Failed to load channels');
    }
  } catch (error) {
    document.getElementById('out').textContent = 'Error: ' + error.message;
  }
}

function selectChannel() {
  const select = document.getElementById('channelSelect');
  const selectedIndex = select.value;
  
  if (selectedIndex && channelsData[selectedIndex]) {
    const channel = channelsData[selectedIndex];
    document.getElementById('hls').value = channel.url || '';
    document.getElementById('id').value = channel.name.toLowerCase().replace(/[^a-z0-9]+/g, '_') || 'channel_stream';
    
    document.getElementById('out').textContent = 'Selected channel: ' + channel.name + '\nGroup: ' + (channel.group || 'N/A') + '\nURL: ' + channel.url;
    
    // ÙØ­Øµ Ø§Ù„Ù…ØµØ¯Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‚Ù†Ø§Ø©
    if (channel.url) {
      checkSource(channel.url, channel.name);
    }
  } else {
    // Ø¥Ø®ÙØ§Ø¡ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ­Øµ
    const statusDiv = document.getElementById('sourceStatus');
    statusDiv.classList.remove('active', 'checking', 'available', 'unavailable', 'timeout');
  }
}

// Ù…ØªØºÙŠØ± Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙØ­Øµ
let sourceCheckAbortController = null;

async function checkSource(url, channelName) {
  const statusDiv = document.getElementById('sourceStatus');
  const statusText = document.getElementById('sourceStatusText');
  
  if (!statusDiv || !statusText) {
    console.error('Source status elements not found');
    return;
  }
  
  // Ø¥ÙŠÙ‚Ø§Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙØ­Øµ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¥Ù† ÙˆØ¬Ø¯Øª
  if (sourceCheckAbortController) {
    sourceCheckAbortController.abort();
  }
  
  // Ø¥Ù†Ø´Ø§Ø¡ AbortController Ø¬Ø¯ÙŠØ¯
  sourceCheckAbortController = new AbortController();
  const signal = sourceCheckAbortController.signal;
  
  // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§Ù„Ø© Ø§Ù„ÙØ­Øµ
  statusDiv.classList.add('active', 'checking');
  statusDiv.classList.remove('available', 'unavailable', 'timeout');
  statusText.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø§Ù„Ù…ØµØ¯Ø±: ' + (channelName || '...');
  
  try {
    const response = await fetch('/source/check', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ url: url }),
      signal: signal
    });
    
    const result = await response.json();
    
    // Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„ÙØ­Øµ
    statusDiv.classList.remove('checking');
    
    if (result.status === 'available') {
      statusDiv.classList.add('available');
      statusText.textContent = 'âœ… Ø§Ù„Ù…ØµØ¯Ø± Ù…ØªØ§Ø­ (' + result.response_time + 's) - ' + (channelName || 'Ù‚Ù†Ø§Ø©');
      console.log('Source check successful:', result);
    } else if (result.status === 'timeout') {
      statusDiv.classList.add('timeout');
      statusText.textContent = 'â±ï¸ ' + result.message + ' (' + result.response_time + 's)';
      console.warn('Source check timeout:', result);
    } else if (result.status === 'unavailable' || result.status === 'error') {
      statusDiv.classList.add('unavailable');
      statusText.textContent = 'âŒ ' + result.message;
      console.error('Source check failed:', result);
    } else {
      statusDiv.classList.add('unavailable');
      statusText.textContent = 'âš ï¸ Ø­Ø§Ù„Ø© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©: ' + result.status;
    }
    
    // Ø¥ÙŠÙ‚Ø§Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙØ­Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡
    sourceCheckAbortController = null;
    
  } catch (error) {
    // Ø¥ÙŠÙ‚Ø§Ù Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ÙØ­Øµ
    sourceCheckAbortController = null;
    
    // ØªØ¬Ø§Ù‡Ù„ AbortError (ÙŠØ­Ø¯Ø« Ø¹Ù†Ø¯ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø·Ù„Ø¨)
    if (error.name === 'AbortError') {
      console.log('Source check aborted');
      return;
    }
    
    // Ø¥Ø¸Ù‡Ø§Ø± Ø®Ø·Ø£
    statusDiv.classList.remove('checking');
    statusDiv.classList.add('unavailable');
    statusText.textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ Ø§Ù„Ù…ØµØ¯Ø±: ' + error.message;
    console.error('Source check error:', error);
  }
}

// Streams table management
let autoRefreshInterval = null;
let autoRefreshEnabled = true;

function formatUptime(seconds) {
  if (!seconds) return 'N/A';
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return hours + 'h ' + minutes + 'm ' + secs + 's';
  } else if (minutes > 0) {
    return minutes + 'm ' + secs + 's';
  } else {
    return secs + 's';
  }
}

function formatSize(bytes) {
  if (!bytes || bytes === 0) return '0 B';
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

async function refreshStreamsTable() {
  try {
    const response = await fetch('/list', {
      method: 'GET',
      headers: {
        'Authorization': authHeader()
      }
    });
    
    const result = await response.json();
    const tbody = document.getElementById('streamsTableBody');
    const countSpan = document.getElementById('streamsCount');
    
    if (response.ok && result.streams) {
      const streams = result.streams;
      countSpan.textContent = '(' + streams.length + ')';
      
      if (streams.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">No streams found</td></tr>';
      } else {
        tbody.innerHTML = streams.map(stream => {
          const statusClass = stream.running ? 'status-running' : 'status-stopped';
          const statusText = stream.running ? 'Running' : 'Stopped';
          const uptime = stream.uptime_seconds ? formatUptime(stream.uptime_seconds) : 'N/A';
          const logSize = formatSize(stream.log_size || 0);
          const streamId = stream.id;
          
          const actionButtons = stream.running ? 
            '<button onclick="stopStream(\'' + streamId + '\')" style="background: #ff3b30;" title="Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©">â¹ Ø¥ÙŠÙ‚Ø§Ù</button>' +
            '<button onclick="viewStreamLogs(\'' + streamId + '\')" title="Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¬Ù„Ø§Øª">ğŸ“„ Ø³Ø¬Ù„Ø§Øª</button>' +
            '<button onclick="killAndDeleteStream(\'' + streamId + '\')" style="background: #8e0000;" title="Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©">ğŸ—‘ï¸ Ø­Ø°Ù</button>' :
            '<button onclick="cleanupStream(\'' + streamId + '\')" style="background: #666;" title="ØªÙ†Ø¸ÙŠÙ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ø§Ù„Ù‚Ø©">ğŸ—‘ï¸ Ø­Ø°Ù</button>';
          
          return '<tr>' +
            '<td><strong>' + stream.id + '</strong></td>' +
            '<td><span class="status-badge ' + statusClass + '">' + statusText + '</span></td>' +
            '<td style="font-family: monospace;">' + (stream.pid || 'N/A') + '</td>' +
            '<td>' + uptime + '</td>' +
            '<td>' + logSize + '</td>' +
            '<td><div class="action-buttons">' + actionButtons + '</div></td>' +
            '</tr>';
        }).join('');
      }
      
      document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    } else {
      tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #ff3b30; padding: 20px;">Error loading streams: ' + (result.error || 'Unknown error') + '</td></tr>';
    }
  } catch (error) {
    const tbody = document.getElementById('streamsTableBody');
    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #ff3b30; padding: 20px;">Error: ' + error.message + '</td></tr>';
  }
}

async function stopStream(streamId) {
  if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '"?')) {
    return;
  }
  
  try {
    // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const row = document.querySelector('tr:has(button[onclick*="\'' + streamId + '\'"])');
    if (row) {
      const statusBadge = row.querySelector('.status-badge');
      if (statusBadge) {
        statusBadge.textContent = 'Ø¥ÙŠÙ‚Ø§Ù...';
        statusBadge.style.background = '#ff9500';
      }
    }
    
    const response = await fetch('/stop', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert('âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© \"' + streamId + '\" Ø¨Ù†Ø¬Ø§Ø­');
      document.getElementById('out').textContent = 'âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '" Ø¨Ù†Ø¬Ø§Ø­\n' + JSON.stringify(result, null, 2);
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù…Ø¹ Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
      if (row) {
        row.style.transition = 'background-color 0.3s';
        row.style.backgroundColor = '#ff3b3020';
        setTimeout(() => {
          refreshStreamsTable();
        }, 500);
      } else {
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error'));
      document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error');
      // Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù„Ø¥Ø²Ø§Ù„Ø© Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
      setTimeout(refreshStreamsTable, 500);
    }
  } catch (error) {
    alert('âŒ Ø®Ø·Ø£: ' + error.message);
    document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£: ' + error.message;
    setTimeout(refreshStreamsTable, 500);
  }
}

async function viewStreamLogs(streamId) {
  document.getElementById('id').value = streamId;
  await viewLogs();
}

async function killAndDeleteStream(streamId) {
  if (!confirm('âš ï¸ ØªØ­Ø°ÙŠØ±: Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '"?\n\nØ³ÙŠØªÙ…:\n- Ù‚ØªÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© ÙÙ‚Ø·\n- Ø­Ø°Ù Ù…Ù„ÙØ§Øª PID ÙˆØ§Ù„Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø©\n\nâš ï¸ Ø³ÙŠØªÙ… Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹')) {
    return;
  }
  
  try {
    // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
    const row = document.querySelector('tr:has(button[onclick*="\'' + streamId + '\'"])');
    if (row) {
      row.style.transition = 'opacity 0.3s';
      row.style.opacity = '0.5';
      const statusBadge = row.querySelector('.status-badge');
      if (statusBadge) {
        statusBadge.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­Ø°Ù...';
        statusBadge.style.background = '#8e0000';
      }
    }
    
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… endpoint Ù…Ø®ØµØµ Ù„Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­Ø¯Ø¯Ø© ÙÙ‚Ø·
    const response = await fetch('/kill-and-cleanup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert('âœ… ØªÙ… Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '" Ø¨Ù†Ø¬Ø§Ø­\n\nÙ…Ù„Ø§Ø­Ø¸Ø©: ØªÙ… Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
      document.getElementById('out').textContent = 'âœ… ØªÙ… Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '" Ø¨Ù†Ø¬Ø§Ø­\n\nÙ…Ù„Ø§Ø­Ø¸Ø©: ' + (result.note || 'ØªÙ… Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹') + '\n' + JSON.stringify(result, null, 2);
      
      // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØµÙ Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù…Ø¹ Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
      if (row) {
        row.style.transition = 'opacity 0.3s, transform 0.3s';
        row.style.opacity = '0';
        row.style.transform = 'translateX(-100%)';
        setTimeout(() => {
          refreshStreamsTable();
        }, 300);
      } else {
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error'));
      document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error');
      if (row) {
        row.style.opacity = '1';
      }
      setTimeout(refreshStreamsTable, 500);
    }
  } catch (error) {
    alert('âŒ Ø®Ø·Ø£: ' + error.message);
    document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£: ' + error.message;
    setTimeout(refreshStreamsTable, 500);
  }
}

async function cleanupStream(streamId) {
  if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ø§Ù„Ù‚Ø© "' + streamId + '"?\nØ³ÙŠØªÙ… Ù‚ØªÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ÙˆØ­Ø°Ù Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø©.\n\nâš ï¸ Ø³ÙŠØªÙ… Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹')) {
    return;
  }
  
  try {
    // Ø§Ø³ØªØ®Ø¯Ø§Ù… endpoint Ù…Ø®ØµØµ Ù„Ù‚ØªÙ„ ÙˆØ­Ø°Ù Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ø­Ø¯Ø¯Ø© ÙÙ‚Ø·
    const response = await fetch('/kill-and-cleanup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert('âœ… ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ø§Ù„Ù‚Ø© "' + streamId + '" Ø¨Ù†Ø¬Ø§Ø­');
      document.getElementById('out').textContent = 'âœ… ØªÙ… ØªÙ†Ø¸ÙŠÙ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© "' + streamId + '"\n\nÙ…Ù„Ø§Ø­Ø¸Ø©: ' + (result.note || 'ØªÙ… Ø§Ù„ØªØ£Ø«ÙŠØ± ÙÙ‚Ø· Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹') + '\n' + JSON.stringify(result, null, 2);
      
      // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØµÙ Ù…Ù† Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ù…Ø¹ Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
      const row = document.querySelector('tr:has(button[onclick*="\'' + streamId + '\'"])');
      if (row) {
        row.style.transition = 'opacity 0.3s';
        row.style.opacity = '0';
        setTimeout(() => {
          refreshStreamsTable();
        }, 300);
      } else {
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error'));
      document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (result.error || 'Unknown error');
    }
  } catch (error) {
    alert('âŒ Ø®Ø·Ø£: ' + error.message);
    document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£: ' + error.message;
  }
}

function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  document.getElementById('autoRefreshStatus').textContent = autoRefreshEnabled ? 'Enabled' : 'Disabled';
  
  if (autoRefreshEnabled) {
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
}

function startAutoRefresh() {
  stopAutoRefresh(); // Clear existing interval
  refreshStreamsTable(); // Initial load
  autoRefreshInterval = setInterval(refreshStreamsTable, 5000); // Refresh every 5 seconds
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

async function saveSettings() {
  const settings = {
    token: document.getElementById('token').value,
    id: document.getElementById('id').value,
    hls: document.getElementById('hls').value,
    rtmp: document.getElementById('rtmp').value,
    image: document.getElementById('image').value,
    extra: document.getElementById('extra').value
  };
  
  try {
    const response = await fetch('/settings/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(settings)
    });
    
    const result = await response.json();
    
    if (response.ok) {
      // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
      alert('âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!');
      document.getElementById('out').textContent = 'âœ… Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªÙ… Ø­ÙØ¸Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­\n' + JSON.stringify(result, null, 2);
    } else {
      alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: ' + (result.error || 'Unknown error'));
      document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: ' + (result.error || 'Unknown error');
    }
  } catch (error) {
    alert('âŒ Ø®Ø·Ø£: ' + error.message);
    document.getElementById('out').textContent = 'âŒ Ø®Ø·Ø£: ' + error.message;
  }
}

async function loadSettings() {
  try {
    // Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† DOM Ø¬Ø§Ù‡Ø² ØªÙ…Ø§Ù…Ø§Ù‹
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const response = await fetch('/settings/load');
    const result = await response.json();
    
    console.log('Settings load response:', result);
    
    if (response.ok && result.status === 'loaded' && result.settings) {
      const settings = result.settings;
      let loadedCount = 0;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù‚Ø¨Ù„ ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ…
      const tokenEl = document.getElementById('token');
      const idEl = document.getElementById('id');
      const hlsEl = document.getElementById('hls');
      const rtmpEl = document.getElementById('rtmp');
      const imageEl = document.getElementById('image');
      const extraEl = document.getElementById('extra');
      
      if (tokenEl && settings.token !== undefined && settings.token !== null && settings.token !== '') {
        tokenEl.value = settings.token;
        loadedCount++;
        console.log('Loaded token:', settings.token);
      }
      if (idEl && settings.id !== undefined && settings.id !== null && settings.id !== '') {
        idEl.value = settings.id;
        loadedCount++;
        console.log('Loaded id:', settings.id);
      }
      if (hlsEl && settings.hls !== undefined && settings.hls !== null && settings.hls !== '') {
        hlsEl.value = settings.hls;
        loadedCount++;
        console.log('Loaded hls:', settings.hls);
      }
      if (rtmpEl && settings.rtmp !== undefined && settings.rtmp !== null && settings.rtmp !== '') {
        rtmpEl.value = settings.rtmp;
        loadedCount++;
        console.log('Loaded rtmp:', settings.rtmp);
      }
      if (imageEl && settings.image !== undefined && settings.image !== null && settings.image !== '') {
        imageEl.value = settings.image;
        loadedCount++;
        console.log('Loaded image:', settings.image);
      }
      if (extraEl && settings.extra !== undefined && settings.extra !== null && settings.extra !== '') {
        extraEl.value = settings.extra;
        loadedCount++;
        console.log('Loaded extra:', settings.extra);
      }
      
      // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
      setTimeout(() => {
        generateFFmpegCommand();
      }, 100);
      
      if (loadedCount > 0) {
        const message = 'âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© (' + loadedCount + ' Ø­Ù‚ÙˆÙ„)';
        console.log(message);
        document.getElementById('out').textContent = message;
      } else {
        const message = 'â„¹ï¸ ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù„ÙƒÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙØ§Ø±ØºØ©';
        console.log(message);
        document.getElementById('out').textContent = message;
      }
    } else if (result.status === 'not_found') {
      // No saved settings, use defaults - this is fine
      const message = `â„¹ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©ØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©`;
      console.log(message);
      document.getElementById('out').textContent = message;
      // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø­ØªÙ‰ Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø­ÙÙˆØ¸Ø© (Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©)
      setTimeout(() => {
        generateFFmpegCommand();
      }, 100);
    } else {
      console.log('Unexpected response:', result);
      document.getElementById('out').textContent = 'âš ï¸ Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©: ' + JSON.stringify(result);
      // Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø¹Ù„Ù‰ Ø£ÙŠ Ø­Ø§Ù„
      setTimeout(() => {
        generateFFmpegCommand();
      }, 100);
    }
  } catch (error) {
    console.error('Error loading settings:', error);
    document.getElementById('out').textContent = 'âš ï¸ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª: ' + error.message;
    // Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø¹Ù„Ù‰ Ø£ÙŠ Ø­Ø§Ù„
    setTimeout(() => {
      generateFFmpegCommand();
    }, 100);
  }
}

// Load channels and streams on page load
window.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, starting initialization...');
  
  // Ø¥Ø¶Ø§ÙØ© event listeners Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù…Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ (Ù‚Ø¨Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª)
  const hlsInput = document.getElementById('hls');
  const rtmpInput = document.getElementById('rtmp');
  const imageInput = document.getElementById('image');
  const extraInput = document.getElementById('extra');
  
  if (hlsInput) {
    hlsInput.addEventListener('input', generateFFmpegCommand);
    hlsInput.addEventListener('change', generateFFmpegCommand);
  }
  if (rtmpInput) {
    rtmpInput.addEventListener('input', generateFFmpegCommand);
    rtmpInput.addEventListener('change', generateFFmpegCommand);
  }
  if (imageInput) {
    imageInput.addEventListener('input', generateFFmpegCommand);
    imageInput.addEventListener('change', generateFFmpegCommand);
  }
  if (extraInput) {
    extraInput.addEventListener('input', generateFFmpegCommand);
    extraInput.addEventListener('change', generateFFmpegCommand);
  }
  
  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ Ù…Ø¹ ØªØ£Ø®ÙŠØ± ØµØºÙŠØ± Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¬Ø§Ù‡Ø²ÙŠØ© DOM
  setTimeout(() => {
    loadSettings();
    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª (Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯Ù‡ Ø£ÙŠØ¶Ø§Ù‹ ÙÙŠ loadSettings)
    setTimeout(() => {
      generateFFmpegCommand();
    }, 500);
  }, 200);
  
  loadChannels();
  startAutoRefresh();
  
    // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø£ÙˆÙ„ÙŠ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
    setTimeout(() => {
      generateFFmpegCommand();
    }, 1000);
    
    // Ø¥Ø¶Ø§ÙØ© event listener Ù„Ù„Ø²Ø± Ù„Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ (Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„Ù‡)
    const generateBtn = document.getElementById('generateCommandBtn');
    if (generateBtn) {
      generateBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Generate button clicked manually');
        generateFFmpegCommand();
        return false;
      });
    }
  });

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  stopAutoRefresh();
});

async function apiCall(endpoint, method, payload = null) {
  const options = {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': authHeader()
    }
  };
  
  if (payload) {
    options.body = JSON.stringify(payload);
  }
  
  try {
    const response = await fetch(endpoint, options);
    const text = await response.text();
    let output = 'Status: ' + response.status + ' ' + response.statusText + '\n\n';
    
    try {
      const json = JSON.parse(text);
      output += JSON.stringify(json, null, 2);
    } catch {
      output += text;
    }
    
    document.getElementById('out').textContent = output;
  } catch (error) {
    document.getElementById('out').textContent = 'Error: ' + error.message;
  }
}

function generateFFmpegCommand() {
  console.log('generateFFmpegCommand called');
  const hlsEl = document.getElementById('hls');
  const rtmpEl = document.getElementById('rtmp');
  const imageEl = document.getElementById('image');
  const extraEl = document.getElementById('extra');
  const commandEl = document.getElementById('ffmpegCommand');
  
  if (!commandEl) {
    console.error('ffmpegCommand element not found');
    return;
  }
  
  if (!hlsEl || !rtmpEl) {
    console.error('hls or rtmp elements not found');
    commandEl.value = '# Ø®Ø·Ø£: Ø§Ù„Ø­Ù‚ÙˆÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©';
    return;
  }
  
  let hls = hlsEl.value.trim();
  let rtmp = rtmpEl.value.trim();
  const image = imageEl ? imageEl.value.trim() : '';
  const extraRaw = extraEl ? extraEl.value.trim() : '';
  
  console.log('HLS:', hls);
  console.log('RTMP:', rtmp);
  console.log('Image:', image);
  console.log('Extra:', extraRaw);
  
  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ÙØ§Ø±ØºØ©
  if (!hls || hls === '' || hls.trim() === '') {
    commandEl.value = '# Ø§Ù…Ù„Ø£ HLS URL Ø£ÙˆÙ„Ø§Ù‹';
    console.warn('HLS URL is empty');
    return;
  }
  
  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† RTMP URL - Ø¥Ø°Ø§ ÙƒØ§Ù† placeholderØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¹Ù„Ù‰ Ø£ÙŠ Ø­Ø§Ù„
  if (!rtmp || rtmp.trim() === '' || rtmp.trim() === '{RTMP_URL_PLACEHOLDER}') {
    commandEl.value = '# Ø§Ù…Ù„Ø£ RTMP URL';
    console.warn('RTMP URL is empty');
    return;
  }
  
  // Ø¥Ø°Ø§ ÙƒØ§Ù† RTMP URL ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ placeholderØŒ Ù†Ø­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ø¹Ù„Ù‰ Ø£ÙŠ Ø­Ø§Ù„ (Ù„Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ)
  if (rtmp.includes('{RTMP_URL_PLACEHOLDER}') || rtmp.includes('{TOKEN_PLACEHOLDER}')) {
    console.warn('RTMP URL contains placeholder, generating command anyway');
    // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø­ØªÙ‰ Ù„Ùˆ ÙƒØ§Ù†Øª placeholder (Ù„Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ)
  }
  
  // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† flags Ø¥Ø¶Ø§ÙÙŠØ©)
  let command = 'ffmpeg -re -i "' + hls + '"';
  
  // Ø¥Ø¶Ø§ÙØ© image Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯
  if (image && image !== '') {
    command += ' -i "' + image + '"';
  }
  
  // Ø¥Ø¶Ø§ÙØ© extra_args Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
  if (extraRaw && extraRaw !== '') {
    try {
      const parsed = JSON.parse(extraRaw);
      if (Array.isArray(parsed) && parsed.length > 0) {
        // Ø¥Ø¶Ø§ÙØ© extra args
        parsed.forEach(arg => {
          command += ' ' + arg;
        });
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ filtersØŒ Ù†Ø­ØªØ§Ø¬ re-encoding
        const argsStr = parsed.join(' ').toLowerCase();
        const hasFilters = argsStr.includes('-filter_complex') || argsStr.includes('-vf') || 
                          argsStr.includes('overlay') || argsStr.includes('scale') || 
                          argsStr.includes('crop');
        
        if (hasFilters) {
          command += ' -c:v libx264 -preset veryfast -tune zerolatency -b:v 2000k -g 50 -keyint_min 25 -sc_threshold 0 -pix_fmt yuv420p';
        } else {
          command += ' -c:v copy';
        }
      } else {
        command += ' -c:v copy';
      }
    } catch (e) {
      command += ' -c:v copy';
    }
  } else if (image && image !== '') {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ image ÙÙ‚Ø·ØŒ Ù†Ø­ØªØ§Ø¬ re-encoding
    command += ' -filter_complex "[0:v][1:v]overlay=(W-w)/2:(H-h)/2:format=auto" -c:v libx264 -preset veryfast -tune zerolatency -b:v 2000k -g 50 -keyint_min 25 -sc_threshold 0 -pix_fmt yuv420p';
  } else {
    // Ù†Ø³Ø® Ù…Ø¨Ø§Ø´Ø±
    command += ' -c:v copy';
  }
  
  // Ø§Ù„ØµÙˆØª Ø¯Ø§Ø¦Ù…Ø§Ù‹ copy
  command += ' -c:a copy';
  
  // Output format (Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† flags Ø¥Ø¶Ø§ÙÙŠØ©)
  command += ' -f flv "' + rtmp + '"';
  
  console.log('Generated command:', command);
  commandEl.value = command;
  console.log('Command set to element, value length:', commandEl.value.length);
}

function copyFFmpegCommand(event) {
  const commandField = document.getElementById('ffmpegCommand');
  if (!commandField || !commandField.value || commandField.value.startsWith('#')) {
    alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ù…Ø± Ù„Ù„Ù†Ø³Ø®. Ø§Ù…Ù„Ø£ HLS URL Ùˆ RTMP URL Ø£ÙˆÙ„Ø§Ù‹.');
    return;
  }
  
  commandField.select();
  commandField.setSelectionRange(0, 99999); // For mobile devices
  
  try {
    const successful = document.execCommand('copy');
    if (successful) {
      // Ø¥Ø¸Ù‡Ø§Ø± Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
      const button = event.target;
      const originalText = button.textContent;
      button.textContent = 'âœ… ØªÙ… Ø§Ù„Ù†Ø³Ø®!';
      button.style.background = '#34c759';
      setTimeout(() => {
        button.textContent = originalText;
        button.style.background = '#0a84ff';
      }, 2000);
    } else {
      // Fallback: Ø§Ø³ØªØ®Ø¯Ø§Ù… Clipboard API Ø§Ù„Ø­Ø¯ÙŠØ«
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(commandField.value).then(() => {
          const button = event.target;
          const originalText = button.textContent;
          button.textContent = 'âœ… ØªÙ… Ø§Ù„Ù†Ø³Ø®!';
          button.style.background = '#34c759';
          setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#0a84ff';
          }, 2000);
        }).catch(() => {
          alert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ ÙŠØ¯ÙˆÙŠØ§Ù‹ ÙˆÙ†Ø³Ø®Ù‡ (Ctrl+C Ø£Ùˆ Cmd+C).');
        });
      } else {
        alert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ ÙŠØ¯ÙˆÙŠØ§Ù‹ ÙˆÙ†Ø³Ø®Ù‡ (Ctrl+C Ø£Ùˆ Cmd+C).');
      }
    }
  } catch (err) {
    // Fallback: Ø§Ø³ØªØ®Ø¯Ø§Ù… Clipboard API
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(commandField.value).then(() => {
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'âœ… ØªÙ… Ø§Ù„Ù†Ø³Ø®!';
        button.style.background = '#34c759';
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = '#0a84ff';
        }, 2000);
      }).catch(() => {
        alert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ ÙŠØ¯ÙˆÙŠØ§Ù‹ ÙˆÙ†Ø³Ø®Ù‡.');
      });
    } else {
      alert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Øµ ÙŠØ¯ÙˆÙŠØ§Ù‹ ÙˆÙ†Ø³Ø®Ù‡.');
    }
  }
}

async function start() {
  const payload = {
    id: document.getElementById('id').value,
    hls: document.getElementById('hls').value,
    rtmp: document.getElementById('rtmp').value,
  };
  
  // ÙÙ‚Ø· Ø£Ø¶Ù image Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØºÙŠØ± ÙØ§Ø±ØºØ©
  const image = document.getElementById('image').value.trim();
  if (image && image !== '') {
    payload.image = image;
    payload.overlay_mode = 'full';
  }
  
  // ÙÙ‚Ø· Ø£Ø¶Ù extra_args Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØºÙŠØ± ÙØ§Ø±ØºØ©
  const extraRaw = document.getElementById('extra').value.trim();
  if (extraRaw && extraRaw !== '') {
    try {
      const parsed = JSON.parse(extraRaw);
      // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„ÙŠØ³Øª ÙØ§Ø±ØºØ©
      if (Array.isArray(parsed) && parsed.length > 0) {
        payload.extra_args = parsed;
      }
    } catch (e) {
      alert('extra_args must be valid JSON array');
      return;
    }
  }
  
  // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ image Ø£Ùˆ extra_argsØŒ Ø³ÙŠØªÙ… Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (copy)
  await apiCall('/start', 'POST', payload);
  // Refresh streams table after starting
  setTimeout(refreshStreamsTable, 1000);
}

async function stop() {
  const payload = { id: document.getElementById('id').value };
  await apiCall('/stop', 'POST', payload);
  // Refresh streams table after stopping
  setTimeout(refreshStreamsTable, 1000);
}

async function status() {
  const id = document.getElementById('id').value;
  await apiCall('/status?id=' + encodeURIComponent(id), 'GET');
}

async function listStreams() {
  await refreshStreamsTable();
}

async function viewLogs() {
  const id = document.getElementById('id').value;
  await apiCall('/logs?id=' + encodeURIComponent(id) + '&lines=200', 'GET');
}
</script>
</body>
</html>