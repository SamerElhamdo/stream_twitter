<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stream Control</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
      max-width: 1200px;
      margin: 0 auto;
      line-height: 1.6;
    }
    h2 { color: #0a84ff; margin-top: 0; }
    h3 { color: #5ac8fa; margin-top: 24px; }
    label { 
      display: block;
      margin-top: 12px;
      margin-bottom: 4px;
      color: #aaa;
      font-size: 14px;
      font-weight: 500;
    }
        input, textarea, select {
      width: 100%;
      padding: 10px 12px;
      margin: 4px 0 12px 0;
      background: #1a1a1a;
      color: #e0e0e0;
      border: 1px solid #333;
      border-radius: 4px;
      font-size: 14px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #0a84ff;
      box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.2);
    }
    select {
      cursor: pointer;
    }
    input[type="file"] {
      padding: 8px;
      cursor: pointer;
    }
    .channel-select-group {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }
    .channel-select-group select {
      flex: 1;
    }
    .channel-select-group button {
      flex: 0 0 auto;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
      background: #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #333;
    }
    th {
      background: #222;
      color: #0a84ff;
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    td {
      color: #e0e0e0;
      font-size: 13px;
    }
    tr:hover {
      background: #252525;
    }
    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .status-running {
      background: #34c759;
      color: #fff;
    }
    .status-stopped {
      background: #ff3b30;
      color: #fff;
    }
    .action-buttons {
      display: flex;
      gap: 6px;
    }
    .action-buttons button {
      padding: 6px 12px;
      font-size: 12px;
      margin: 0;
    }
    .refresh-indicator {
      color: #666;
      font-size: 12px;
      margin-top: 8px;
    }
    button {
      padding: 10px 16px;
      margin: 6px 4px;
      background: #0a84ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }
    button:hover {
      background: #0071e3;
    }
    button:active {
      background: #0051a5;
    }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 16px 0;
    }
    pre {
      background: #000;
      padding: 16px;
      border-radius: 4px;
      max-height: 400px;
      overflow: auto;
      font-size: 12px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      border: 1px solid #333;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .section {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #222;
    }
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    .source-status {
      margin-top: 12px;
      padding: 8px 12px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      font-size: 12px;
      display: none;
    }
    .source-status.active {
      display: block;
    }
    .source-status.checking {
      color: #0a84ff;
    }
    .source-status.available {
      color: #34c759;
      border-color: #34c759;
    }
    .source-status.unavailable {
      color: #ff3b30;
      border-color: #ff3b30;
    }
    .source-status.timeout {
      color: #ff9500;
      border-color: #ff9500;
    }
  </style>
</head>
<body>
  <h2>Stream Control Panel</h2>
  
  <div class="section">
    <h3>M3U Channel Selector</h3>
    <label>Upload M3U File</label>
    <input type="file" id="m3uFile" accept=".m3u,.m3u8" />
    <button onclick="uploadM3U()" style="margin-top: 8px;">üì§ Upload & Load Channels</button>
    
    <label style="margin-top: 20px;">Select Channel</label>
    <div class="channel-select-group">
      <select id="channelSelect" onchange="selectChannel()">
        <option value="">-- Select a channel --</option>
      </select>
      <button onclick="loadChannels()">üîÑ Reload Channels</button>
    </div>
    <small style="color: #666; display: block; margin-top: -8px; margin-bottom: 12px;">
      Total channels: <span id="channelCount">0</span>
    </small>
    
    <div class="source-status" id="sourceStatus">
      <span id="sourceStatusText">ÿ¨ÿßŸáÿ≤ ŸÑŸÑŸÅÿ≠ÿµ</span>
    </div>
  </div>
  
  <div class="section">
    <h3>Stream Settings</h3>
    <label>Authorization Token</label>
    <input id="token" placeholder="Bearer token" value="Bearer {TOKEN_PLACEHOLDER}" />
    
    <label>Stream ID</label>
    <input id="id" value="full_overlay_test" placeholder="Unique stream identifier" />
    
    <label>HLS URL</label>
    <input id="hls" value="http://5.9.243.47:8080/live/wawi/Yyf6Y7gQwC/664.m3u8" placeholder="Input HLS stream URL" />
    
    <label>RTMP URL</label>
    <input id="rtmp" value="{RTMP_URL_PLACEHOLDER}" placeholder="Output RTMP stream URL" />
    
    <label>Image Path (optional)</label>
    <input id="image" value="" placeholder="Path to overlay image" />
    
    <label>Extra Args (JSON array) ‚Äî leave empty to copy video</label>
    <textarea id="extra" rows="4"></textarea>
  </div>

  <div class="button-group">
    <button onclick="start()">‚ñ∂ Start Stream</button>
    <button onclick="stop()">‚ñ† Stop Stream</button>
    <button onclick="status()">üìä Status</button>
    <button onclick="refreshStreamsTable()">üîÑ Refresh</button>
    <button onclick="viewLogs()">üìÑ View Logs</button>
    <button onclick="saveSettings()" style="background: #34c759;">üíæ ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</button>
  </div>

  <div class="section">
    <h3>Running Streams <span id="streamsCount" style="color: #666; font-size: 14px; font-weight: normal;">(0)</span></h3>
    <div id="streamsTableContainer">
      <table id="streamsTable">
        <thead>
          <tr>
            <th>Stream ID</th>
            <th>Status</th>
            <th>PID</th>
            <th>Uptime</th>
            <th>Log Size</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="streamsTableBody">
          <tr>
            <td colspan="6" style="text-align: center; color: #666; padding: 20px;">
              Loading streams...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="refresh-indicator">
      Auto-refresh: <span id="autoRefreshStatus">Enabled</span> | 
      Last updated: <span id="lastUpdate">Never</span>
      <button onclick="toggleAutoRefresh()" style="margin-left: 12px; padding: 4px 8px; font-size: 11px;">Toggle Auto-Refresh</button>
    </div>
  </div>

  <div class="section">
    <h3>Output</h3>
    <pre id="out">Ready...</pre>
  </div>

<script>
let channelsData = [];

function authHeader() {
  let token = document.getElementById('token').value || '';
  if (!token.startsWith('Bearer ')) {
    token = 'Bearer ' + token;
  }
  return token;
}

async function uploadM3U() {
  const fileInput = document.getElementById('m3uFile');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Please select a file first');
    return;
  }
  
  const formData = new FormData();
  formData.append('file', file);
  
  try {
    const response = await fetch('/m3u/upload', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (response.ok) {
      document.getElementById('out').textContent = `File uploaded successfully: ${result.filename}\\n\\n${JSON.stringify(result, null, 2)}`;
      // Automatically load channels after upload
      await loadChannels();
    } else {
      document.getElementById('out').textContent = `Error: ${result.error}`;
    }
  } catch (error) {
    document.getElementById('out').textContent = `Error: ${error.message}`;
  }
}

async function loadChannels() {
  try {
    const response = await fetch('/m3u/channels');
    const result = await response.json();
    
    if (response.ok && result.channels) {
      channelsData = result.channels;
      const select = document.getElementById('channelSelect');
      
      // Clear existing options except the first one
      select.innerHTML = '<option value="">-- Select a channel --</option>';
      
      // Group channels by group title
      const groupedChannels = {};
      result.channels.forEach((channel, index) => {
        const group = channel.group || 'Other';
        if (!groupedChannels[group]) {
          groupedChannels[group] = [];
        }
        groupedChannels[group].push({...channel, index});
      });
      
      // Add options grouped by category
      Object.keys(groupedChannels).sort().forEach(group => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = group;
        
        groupedChannels[group].forEach(channel => {
          const option = document.createElement('option');
          option.value = channel.index;
          option.textContent = channel.name || 'Unnamed Channel';
          optgroup.appendChild(option);
        });
        
        select.appendChild(optgroup);
      });
      
      document.getElementById('channelCount').textContent = result.count;
      document.getElementById('out').textContent = `Loaded ${result.count} channels from M3U file`;
    } else {
      document.getElementById('out').textContent = `Error: ${result.error || 'Failed to load channels'}`;
    }
  } catch (error) {
    document.getElementById('out').textContent = `Error: ${error.message}`;
  }
}

function selectChannel() {
  const select = document.getElementById('channelSelect');
  const selectedIndex = select.value;
  
  if (selectedIndex && channelsData[selectedIndex]) {
    const channel = channelsData[selectedIndex];
    document.getElementById('hls').value = channel.url || '';
    document.getElementById('id').value = channel.name.toLowerCase().replace(/[^a-z0-9]+/g, '_') || 'channel_stream';
    
    document.getElementById('out').textContent = `Selected channel: ${channel.name}\\nGroup: ${channel.group || 'N/A'}\\nURL: ${channel.url}`;
    
    // ŸÅÿ≠ÿµ ÿßŸÑŸÖÿµÿØÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ÿπŸÜÿØ ÿßÿÆÿ™Ÿäÿßÿ± ÿßŸÑŸÇŸÜÿßÿ©
    if (channel.url) {
      checkSource(channel.url, channel.name);
    }
  } else {
    // ÿ•ÿÆŸÅÿßÿ° ÿ≠ÿßŸÑÿ© ÿßŸÑŸÅÿ≠ÿµ
    const statusDiv = document.getElementById('sourceStatus');
    statusDiv.classList.remove('active', 'checking', 'available', 'unavailable', 'timeout');
  }
}

// ŸÖÿ™ÿ∫Ÿäÿ± ŸÑŸÑÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿπŸÖŸÑŸäÿ© ÿßŸÑŸÅÿ≠ÿµ
let sourceCheckAbortController = null;

async function checkSource(url, channelName) {
  const statusDiv = document.getElementById('sourceStatus');
  const statusText = document.getElementById('sourceStatusText');
  
  if (!statusDiv || !statusText) {
    console.error('Source status elements not found');
    return;
  }
  
  // ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑŸÅÿ≠ÿµ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ÿ•ŸÜ Ÿàÿ¨ÿØÿ™
  if (sourceCheckAbortController) {
    sourceCheckAbortController.abort();
  }
  
  // ÿ•ŸÜÿ¥ÿßÿ° AbortController ÿ¨ÿØŸäÿØ
  sourceCheckAbortController = new AbortController();
  const signal = sourceCheckAbortController.signal;
  
  // ÿ•ÿ∏Ÿáÿßÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑŸÅÿ≠ÿµ
  statusDiv.classList.add('active', 'checking');
  statusDiv.classList.remove('available', 'unavailable', 'timeout');
  statusText.textContent = `‚è≥ ÿ¨ÿßÿ±Ÿä ŸÅÿ≠ÿµ ÿßŸÑŸÖÿµÿØÿ±: ${channelName || '...'}`;
  
  try {
    const response = await fetch('/source/check', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ url: url }),
      signal: signal
    });
    
    const result = await response.json();
    
    // ÿ•ÿ≤ÿßŸÑÿ© ÿ≠ÿßŸÑÿ© ÿßŸÑŸÅÿ≠ÿµ
    statusDiv.classList.remove('checking');
    
    if (result.status === 'available') {
      statusDiv.classList.add('available');
      statusText.textContent = `‚úÖ ÿßŸÑŸÖÿµÿØÿ± ŸÖÿ™ÿßÿ≠ (${result.response_time}s) - ${channelName || 'ŸÇŸÜÿßÿ©'}`;
      console.log('Source check successful:', result);
    } else if (result.status === 'timeout') {
      statusDiv.classList.add('timeout');
      statusText.textContent = `‚è±Ô∏è ${result.message} (${result.response_time}s)`;
      console.warn('Source check timeout:', result);
    } else if (result.status === 'unavailable' || result.status === 'error') {
      statusDiv.classList.add('unavailable');
      statusText.textContent = `‚ùå ${result.message}`;
      console.error('Source check failed:', result);
    } else {
      statusDiv.classList.add('unavailable');
      statusText.textContent = `‚ö†Ô∏è ÿ≠ÿßŸÑÿ© ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅÿ©: ${result.status}`;
    }
    
    // ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑŸÅÿ≠ÿµ ÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ°
    sourceCheckAbortController = null;
    
  } catch (error) {
    // ÿ•ŸäŸÇÿßŸÅ ÿπŸÖŸÑŸäÿ© ÿßŸÑŸÅÿ≠ÿµ
    sourceCheckAbortController = null;
    
    // ÿ™ÿ¨ÿßŸáŸÑ AbortError (Ÿäÿ≠ÿØÿ´ ÿπŸÜÿØ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿ∑ŸÑÿ®)
    if (error.name === 'AbortError') {
      console.log('Source check aborted');
      return;
    }
    
    // ÿ•ÿ∏Ÿáÿßÿ± ÿÆÿ∑ÿ£
    statusDiv.classList.remove('checking');
    statusDiv.classList.add('unavailable');
    statusText.textContent = `‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ŸÅÿ≠ÿµ ÿßŸÑŸÖÿµÿØÿ±: ${error.message}`;
    console.error('Source check error:', error);
  }
}

// Streams table management
let autoRefreshInterval = null;
let autoRefreshEnabled = true;

function formatUptime(seconds) {
  if (!seconds) return 'N/A';
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  if (hours > 0) {
    return `${hours}h ${minutes}m ${secs}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  } else {
    return `${secs}s`;
  }
}

function formatSize(bytes) {
  if (!bytes || bytes === 0) return '0 B';
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
}

async function refreshStreamsTable() {
  try {
    const response = await fetch('/list', {
      method: 'GET',
      headers: {
        'Authorization': authHeader()
      }
    });
    
    const result = await response.json();
    const tbody = document.getElementById('streamsTableBody');
    const countSpan = document.getElementById('streamsCount');
    
    if (response.ok && result.streams) {
      const streams = result.streams;
      countSpan.textContent = `(${streams.length})`;
      
      if (streams.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="6" style="text-align: center; color: #666; padding: 20px;">
              No streams found
            </td>
          </tr>
        `;
      } else {
        tbody.innerHTML = streams.map(stream => {
          const statusClass = stream.running ? 'status-running' : 'status-stopped';
          const statusText = stream.running ? 'Running' : 'Stopped';
          const uptime = stream.uptime_seconds ? formatUptime(stream.uptime_seconds) : 'N/A';
          const logSize = formatSize(stream.log_size || 0);
          const streamId = stream.id;
          
          return `
            <tr>
              <td><strong>${stream.id}</strong></td>
              <td><span class="status-badge ${statusClass}">${statusText}</span></td>
              <td style="font-family: monospace;">${stream.pid || 'N/A'}</td>
              <td>${uptime}</td>
              <td>${logSize}</td>
              <td>
                <div class="action-buttons">
                  ${stream.running ? 
                    `<button onclick="stopStream('` + streamId + `')" style="background: #ff3b30;" title="ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©">‚èπ ÿ•ŸäŸÇÿßŸÅ</button>
                     <button onclick="viewStreamLogs('` + streamId + `')" title="ÿπÿ±ÿ∂ ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™">üìÑ ÿ≥ÿ¨ŸÑÿßÿ™</button>
                     <button onclick="killAndDeleteStream('` + streamId + `')" style="background: #8e0000;" title="ŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©">üóëÔ∏è ÿ≠ÿ∞ŸÅ</button>` : 
                    `<button onclick="cleanupStream('` + streamId + `')" style="background: #666;" title="ÿ™ŸÜÿ∏ŸäŸÅ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿπÿßŸÑŸÇÿ©">üóëÔ∏è ÿ≠ÿ∞ŸÅ</button>`
                  }
                </div>
              </td>
            </tr>
          `;
        }).join('');
      }
      
      document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    } else {
      tbody.innerHTML = `
        <tr>
          <td colspan="6" style="text-align: center; color: #ff3b30; padding: 20px;">
            Error loading streams: ${result.error || 'Unknown error'}
          </td>
        </tr>
      `;
    }
  } catch (error) {
    const tbody = document.getElementById('streamsTableBody');
    tbody.innerHTML = `
      <tr>
        <td colspan="6" style="text-align: center; color: #ff3b30; padding: 20px;">
          Error: ${error.message}
        </td>
      </tr>
    `;
  }
}

async function stopStream(streamId) {
  if (!confirm(`ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}"?`)) {
    return;
  }
  
  try {
    // ÿ•ÿ∏Ÿáÿßÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
    const row = document.querySelector(`tr:has(button[onclick*="'${streamId}'"])`);
    if (row) {
      const statusBadge = row.querySelector('.status-badge');
      if (statusBadge) {
        statusBadge.textContent = 'ÿ•ŸäŸÇÿßŸÅ...';
        statusBadge.style.background = '#ff9500';
      }
    }
    
    const response = await fetch('/stop', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert(`‚úÖ ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}" ÿ®ŸÜÿ¨ÿßÿ≠`);
      document.getElementById('out').textContent = `‚úÖ ÿ™ŸÖ ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}" ÿ®ŸÜÿ¨ÿßÿ≠\\n${JSON.stringify(result, null, 2)}`;
      
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÖÿπ ÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ
      if (row) {
        row.style.transition = 'background-color 0.3s';
        row.style.backgroundColor = '#ff3b3020';
        setTimeout(() => {
          refreshStreamsTable();
        }, 500);
      } else {
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`);
      document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸäŸÇÿßŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`;
      // ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÑÿ•ÿ≤ÿßŸÑÿ© ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
      setTimeout(refreshStreamsTable, 500);
    }
  } catch (error) {
    alert(`‚ùå ÿÆÿ∑ÿ£: ${error.message}`);
    document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£: ${error.message}`;
    setTimeout(refreshStreamsTable, 500);
  }
}

async function viewStreamLogs(streamId) {
  document.getElementById('id').value = streamId;
  await viewLogs();
}

async function killAndDeleteStream(streamId) {
  if (!confirm(`‚ö†Ô∏è ÿ™ÿ≠ÿ∞Ÿäÿ±: ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}"?\\n\\nÿ≥Ÿäÿ™ŸÖ:\\n- ŸÇÿ™ŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ© ÿßŸÑÿÆÿßÿµÿ© ÿ®Ÿáÿ∞Ÿá ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ŸÅŸÇÿ∑\\n- ÿ≠ÿ∞ŸÅ ŸÖŸÑŸÅÿßÿ™ PID ŸàÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑŸÖÿ™ÿπŸÑŸÇÿ©\\n\\n‚ö†Ô∏è ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ŸÅŸÇÿ∑ ÿπŸÑŸâ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ`)) {
    return;
  }
  
  try {
    // ÿ•ÿ∏Ÿáÿßÿ± ÿ≠ÿßŸÑÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
    const row = document.querySelector(`tr:has(button[onclick*="'${streamId}'"])`);
    if (row) {
      row.style.transition = 'opacity 0.3s';
      row.style.opacity = '0.5';
      const statusBadge = row.querySelector('.status-badge');
      if (statusBadge) {
        statusBadge.textContent = 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ∞ŸÅ...';
        statusBadge.style.background = '#8e0000';
      }
    }
    
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ endpoint ŸÖÿÆÿµÿµ ŸÑŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖÿ≠ÿØÿØÿ© ŸÅŸÇÿ∑
    const response = await fetch('/kill-and-cleanup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert(`‚úÖ ÿ™ŸÖ ŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}" ÿ®ŸÜÿ¨ÿßÿ≠\\n\\nŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿ™ŸÖ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ŸÅŸÇÿ∑ ÿπŸÑŸâ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ`);
      document.getElementById('out').textContent = `‚úÖ ÿ™ŸÖ ŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}" ÿ®ŸÜÿ¨ÿßÿ≠\\n\\nŸÖŸÑÿßÿ≠ÿ∏ÿ©: ${result.note || 'ÿ™ŸÖ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ŸÅŸÇÿ∑ ÿπŸÑŸâ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ'}\\n${JSON.stringify(result, null, 2)}`;
      
      // ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿµŸÅ ŸÖŸÜ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÖÿπ ÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ
      if (row) {
        row.style.transition = 'opacity 0.3s, transform 0.3s';
        row.style.opacity = '0';
        row.style.transform = 'translateX(-100%)';
        setTimeout(() => {
          refreshStreamsTable();
        }, 300);
      } else {
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`);
      document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`;
      if (row) {
        row.style.opacity = '1';
      }
      setTimeout(refreshStreamsTable, 500);
    }
  } catch (error) {
    alert(`‚ùå ÿÆÿ∑ÿ£: ${error.message}`);
    document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£: ${error.message}`;
    setTimeout(refreshStreamsTable, 500);
  }
}

async function cleanupStream(streamId) {
  if (!confirm(`ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿπÿßŸÑŸÇÿ© "${streamId}"?\\nÿ≥Ÿäÿ™ŸÖ ŸÇÿ™ŸÑ ÿßŸÑÿπŸÖŸÑŸäÿ© Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ™ÿπŸÑŸÇÿ©.\\n\\n‚ö†Ô∏è ÿ≥Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ŸÅŸÇÿ∑ ÿπŸÑŸâ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ`)) {
    return;
  }
  
  try {
    // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ endpoint ŸÖÿÆÿµÿµ ŸÑŸÇÿ™ŸÑ Ÿàÿ≠ÿ∞ŸÅ ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖÿ≠ÿØÿØÿ© ŸÅŸÇÿ∑
    const response = await fetch('/kill-and-cleanup', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': authHeader()
      },
      body: JSON.stringify({ id: streamId })
    });
    
    const result = await response.json();
    
    if (response.ok) {
      alert(`‚úÖ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿπÿßŸÑŸÇÿ© "${streamId}" ÿ®ŸÜÿ¨ÿßÿ≠`);
      document.getElementById('out').textContent = `‚úÖ ÿ™ŸÖ ÿ™ŸÜÿ∏ŸäŸÅ Ÿàÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© "${streamId}"\\n\\nŸÖŸÑÿßÿ≠ÿ∏ÿ©: ${result.note || 'ÿ™ŸÖ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ŸÅŸÇÿ∑ ÿπŸÑŸâ ŸÖÿπÿßŸÑÿ¨ÿßÿ™ Ÿáÿ∞ÿß ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ'}\\n${JSON.stringify(result, null, 2)}`;
      
      // ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿµŸÅ ŸÖŸÜ ÿßŸÑÿ¨ÿØŸàŸÑ ŸÖÿπ ÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ
      const row = document.querySelector(`tr:has(button[onclick*="'${streamId}'"])`);
      if (row) {
        row.style.transition = 'opacity 0.3s';
        row.style.opacity = '0';
        setTimeout(() => {
          refreshStreamsTable();
        }, 300);
      } else {
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ¨ÿØŸàŸÑ ÿ®ÿπÿØ ŸÇŸÑŸäŸÑ
        setTimeout(refreshStreamsTable, 500);
      }
    } else {
      alert(`‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`);
      document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©: ${result.error || 'Unknown error'}`;
    }
  } catch (error) {
    alert(`‚ùå ÿÆÿ∑ÿ£: ${error.message}`);
    document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£: ${error.message}`;
  }
}

function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  document.getElementById('autoRefreshStatus').textContent = autoRefreshEnabled ? 'Enabled' : 'Disabled';
  
  if (autoRefreshEnabled) {
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
}

function startAutoRefresh() {
  stopAutoRefresh(); // Clear existing interval
  refreshStreamsTable(); // Initial load
  autoRefreshInterval = setInterval(refreshStreamsTable, 5000); // Refresh every 5 seconds
}

function stopAutoRefresh() {
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

async function saveSettings() {
  const settings = {
    token: document.getElementById('token').value,
    id: document.getElementById('id').value,
    hls: document.getElementById('hls').value,
    rtmp: document.getElementById('rtmp').value,
    image: document.getElementById('image').value,
    extra: document.getElementById('extra').value
  };
  
  try {
    const response = await fetch('/settings/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(settings)
    });
    
    const result = await response.json();
    
    if (response.ok) {
      // ÿ•ÿ∏Ÿáÿßÿ± ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ£ŸÉŸäÿØ
      alert('‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠!');
      document.getElementById('out').textContent = `‚úÖ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿáÿß ÿ®ŸÜÿ¨ÿßÿ≠\\n${JSON.stringify(result, null, 2)}`;
    } else {
      alert('‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™: ' + (result.error || 'Unknown error'));
      document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™: ${result.error || 'Unknown error'}`;
    }
  } catch (error) {
    alert('‚ùå ÿÆÿ∑ÿ£: ' + error.message);
    document.getElementById('out').textContent = `‚ùå ÿÆÿ∑ÿ£: ${error.message}`;
  }
}

async function loadSettings() {
  try {
    // ÿßŸÜÿ™ÿ∏ÿ± ŸÇŸÑŸäŸÑÿßŸã ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ DOM ÿ¨ÿßŸáÿ≤ ÿ™ŸÖÿßŸÖÿßŸã
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const response = await fetch('/settings/load');
    const result = await response.json();
    
    console.log('Settings load response:', result);
    
    if (response.ok && result.status === 'loaded' && result.settings) {
      const settings = result.settings;
      let loadedCount = 0;
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÇÿ®ŸÑ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÇŸäŸÖ
      const tokenEl = document.getElementById('token');
      const idEl = document.getElementById('id');
      const hlsEl = document.getElementById('hls');
      const rtmpEl = document.getElementById('rtmp');
      const imageEl = document.getElementById('image');
      const extraEl = document.getElementById('extra');
      
      if (tokenEl && settings.token !== undefined && settings.token !== null && settings.token !== '') {
        tokenEl.value = settings.token;
        loadedCount++;
        console.log('Loaded token:', settings.token);
      }
      if (idEl && settings.id !== undefined && settings.id !== null && settings.id !== '') {
        idEl.value = settings.id;
        loadedCount++;
        console.log('Loaded id:', settings.id);
      }
      if (hlsEl && settings.hls !== undefined && settings.hls !== null && settings.hls !== '') {
        hlsEl.value = settings.hls;
        loadedCount++;
        console.log('Loaded hls:', settings.hls);
      }
      if (rtmpEl && settings.rtmp !== undefined && settings.rtmp !== null && settings.rtmp !== '') {
        rtmpEl.value = settings.rtmp;
        loadedCount++;
        console.log('Loaded rtmp:', settings.rtmp);
      }
      if (imageEl && settings.image !== undefined && settings.image !== null && settings.image !== '') {
        imageEl.value = settings.image;
        loadedCount++;
        console.log('Loaded image:', settings.image);
      }
      if (extraEl && settings.extra !== undefined && settings.extra !== null && settings.extra !== '') {
        extraEl.value = settings.extra;
        loadedCount++;
        console.log('Loaded extra:', settings.extra);
      }
      
      if (loadedCount > 0) {
        const message = `‚úÖ ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ© (${loadedCount} ÿ≠ŸÇŸàŸÑ)`;
        console.log(message);
        document.getElementById('out').textContent = message;
      } else {
        const message = `‚ÑπÔ∏è ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ŸÑŸÉŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ŸÇŸàŸÑ ŸÅÿßÿ±ÿ∫ÿ©`;
        console.log(message);
        document.getElementById('out').textContent = message;
      }
    } else if (result.status === 'not_found') {
      // No saved settings, use defaults - this is fine
      const message = `‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ©ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©`;
      console.log(message);
      document.getElementById('out').textContent = message;
    } else {
      console.log('Unexpected response:', result);
      document.getElementById('out').textContent = `‚ö†Ô∏è ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπÿ©: ${JSON.stringify(result)}`;
    }
  } catch (error) {
    console.error('Error loading settings:', error);
    document.getElementById('out').textContent = `‚ö†Ô∏è ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™: ${error.message}`;
  }
}

// Load channels and streams on page load
window.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, starting initialization...');
  // ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿ£ŸàŸÑÿßŸã ŸÖÿπ ÿ™ÿ£ÿÆŸäÿ± ÿµÿ∫Ÿäÿ± ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ¨ÿßŸáÿ≤Ÿäÿ© DOM
  setTimeout(() => {
    loadSettings();
  }, 200);
  loadChannels();
  startAutoRefresh();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  stopAutoRefresh();
});

async function apiCall(endpoint, method, payload = null) {
  const options = {
    method: method,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': authHeader()
    }
  };
  
  if (payload) {
    options.body = JSON.stringify(payload);
  }
  
  try {
    const response = await fetch(endpoint, options);
    const text = await response.text();
    let output = `Status: ${response.status} ${response.statusText}\\n\\n`;
    
    try {
      const json = JSON.parse(text);
      output += JSON.stringify(json, null, 2);
    } catch {
      output += text;
    }
    
    document.getElementById('out').textContent = output;
  } catch (error) {
    document.getElementById('out').textContent = `Error: ${error.message}`;
  }
}

async function start() {
  const payload = {
    id: document.getElementById('id').value,
    hls: document.getElementById('hls').value,
    rtmp: document.getElementById('rtmp').value,
  };
  
  // ŸÅŸÇÿ∑ ÿ£ÿ∂ŸÅ image ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫ÿ©
  const image = document.getElementById('image').value.trim();
  if (image && image !== '') {
    payload.image = image;
    payload.overlay_mode = 'full';
  }
  
  // ŸÅŸÇÿ∑ ÿ£ÿ∂ŸÅ extra_args ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ∫Ÿäÿ± ŸÅÿßÿ±ÿ∫ÿ©
  const extraRaw = document.getElementById('extra').value.trim();
  if (extraRaw && extraRaw !== '') {
    try {
      const parsed = JSON.parse(extraRaw);
      // ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ŸÑŸäÿ≥ÿ™ ŸÅÿßÿ±ÿ∫ÿ©
      if (Array.isArray(parsed) && parsed.length > 0) {
        payload.extra_args = parsed;
      }
    } catch (e) {
      alert('extra_args must be valid JSON array');
      return;
    }
  }
  
  // ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ŸáŸÜÿßŸÉ image ÿ£Ÿà extra_argsÿå ÿ≥Ÿäÿ™ŸÖ ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ± (copy)
  await apiCall('/start', 'POST', payload);
  // Refresh streams table after starting
  setTimeout(refreshStreamsTable, 1000);
}

async function stop() {
  const payload = { id: document.getElementById('id').value };
  await apiCall('/stop', 'POST', payload);
  // Refresh streams table after stopping
  setTimeout(refreshStreamsTable, 1000);
}

async function status() {
  const id = document.getElementById('id').value;
  await apiCall(`/status?id=${encodeURIComponent(id)}`, 'GET');
}

async function listStreams() {
  await refreshStreamsTable();
}

async function viewLogs() {
  const id = document.getElementById('id').value;
  await apiCall(`/logs?id=${encodeURIComponent(id)}&lines=200`, 'GET');
}
</script>
</body>
</html>